{"entries":[{"timestamp":1744793049653,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":8779,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":219,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1744793649387,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1,"length1":338,"diffs":[[1,""]]},{"start1":123,"length1":22,"diffs":[[1,"namespace shader {\n"]]},{"start1":494,"length1":20,"diffs":[[1,""]]},{"start1":534,"length1":41,"diffs":[[1,"        12,6,]\n"]]}]}]},{"timestamp":1744794009978,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":915,"length1":22,"diffs":[[1,"        15,11,12,15]\n"]]}]}]},{"timestamp":1744802167519,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":915,"length1":24,"diffs":[[1,"        15,11,12,15],\n"]]}]}]},{"timestamp":1744802168584,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":539,"length1":68,"diffs":[[1,"        [15,15,15,15,\n        15,15,15,15,\n        15,15,15,15,\n        15,15,15,15],\n"]]},{"start1":645,"length1":68,"diffs":[[1,"        [15,12,15,15,\n        15,12,15,12,\n        15,12,15,15,\n        15,15,15,15],\n"]]},{"start1":751,"length1":66,"diffs":[[1,"        [15,11,12,12,\n        12,14,12,8,\n        15,8,12,15,\n        15,12,15,15],\n"]]},{"start1":855,"length1":371,"diffs":[[1,"        [15,13,10,11,\n        14,4,8,6,\n        12,6,11,12,\n        15,11,12,15],[]\n        ]\n"]]},{"start1":950,"length1":111,"diffs":[[1,""]]}]}]},{"timestamp":1744802767541,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1248,"length1":73,"diffs":[[1,"        for (let i = 0;i <<)\n"]]},{"start1":2205,"length1":64,"diffs":[[1,"    let screenRowsBuffer: Buffer;\n    let maskRowsBuffer: Buffer;\n"]]},{"start1":2863,"length1":138,"diffs":[[1,"        if (!screenRowsBuffer || screenRowsBuffer.length < target.height) {\n            screenRowsBuffer = pins.createBuffer(target.height);\n"]]},{"start1":3014,"length1":130,"diffs":[[1,"        if (!maskRowsBuffer || maskRowsBuffer.length < target.height) {\n            maskRowsBuffer = pins.createBuffer(mask.height);\n"]]},{"start1":3415,"length1":131,"diffs":[[1,"            mask.getRows(x, maskRowsBuffer);\n            target.getRows(targetX, screenRowsBuffer);\n"]]}]}]},{"timestamp":1744803364089,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2807,"length1":100,"diffs":[[1,"    function shadeImage(target: Image, left: number, top: number, mask: Image, palette: Buffer) {\n"]]},{"start1":3763,"length1":134,"diffs":[[1,"                if (maskRowsBuffer[y]) screenRowsBuffer[targetY] = palette[screenRowsBuffer[targetY]];\n"]]},{"start1":3880,"length1":57,"diffs":[[1,"            target.setRows(targetX, screenRowsBuffer)\n"]]},{"start1":3951,"length1":92,"diffs":[[1,"    function shadeitem(shadeLevel: number): Buffer {\n        switch (shadeLevel) {\n            case 0: return shadeDark20;\n            case 1: return shadeDark40;\n            case 2: return shadeDark60;\n            case 3: return shadeDark80;\n            case 4: return shadeDark100;\n            case -1: return shadeLight25;\n            case -2: return shadeLight50;\n            case -3: return shadeLight75;\n            case -4: return shadeLight100;\n        }\n        if (shadeLevel < 0) return shadeLight100\n        return shadeDark100\n"]]},{"start1":5129,"length1":31,"diffs":[[1,"        let palette: Buffer;\n"]]},{"start1":5956,"length1":31,"diffs":[[1,"        let palette: Buffer;\n"]]},{"start1":6669,"length1":31,"diffs":[[1,"        let palette: Buffer;\n"]]},{"start1":6738,"length1":54,"diffs":[[1,"        spr.data[\"__palette__\"] = palette as Buffer\n"]]},{"start1":7340,"length1":42,"diffs":[[1,"        protected shadePalette: Buffer;\n"]]},{"start1":7414,"length1":60,"diffs":[[1,"        constructor(image: Image, shadePalette: Buffer) {\n"]]},{"start1":7498,"length1":64,"diffs":[[1,"            this.data[\"__palette__\"] = shadePalette as Buffer\n"]]},{"start1":7724,"length1":122,"diffs":[[1,"            if (this.shadePalette !== this.data[\"__palette__\"]) this.shadePalette = this.data[\"__palette__\"] as Buffer;\n"]]},{"start1":8255,"length1":35,"diffs":[[1,"                screen.mapRect(l, t, this.image.width, this.image.height, this.shadePalette);\n            } else {\n                shadeImage(screen, l, t, this.image, this.shadePalette);\n"]]},{"start1":8457,"length1":69,"diffs":[[1,""]]}]}]},{"timestamp":1744803924074,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1173,"length1":0,"diffs":[[1,"    function createArrNum(len: number) {\n        let uarrnv: number[] = []\n        for (let i = 0;i < len;i++) uarrnv.push(0)\n        return uarrnv\n    }\n\n    /* blank shade */\n    const shadeNull = (hex``)                                 /*   null shade   */\n    const shadeDark100 = (hex`00000000000000000000000000000000`) /*  blank shade   */\n    /* light shade */\n    const shadeLight100 = (hex`01010101010101010101010101010101`) /*   very light   */\n    const shadeLight75 = (hex`0D01050101010101010101010D01010D`) /*  medium light  */\n    const shadeLight50 = (hex`0B010301050109010901050D0301050B`) /*   low light    */\n    const shadeLight25 = (hex`0C01040503010709060103030B01040C`) /* a little light */\n    /* dark shade  */\n    const shadeDark20 = (hex`000D0A0B0E0408060C060B0C0F0B0C0F`) /* a little dark  */\n    const shadeDark40 = (hex`000B0C0C0C0E0C080F080C0F0F0C0F0F`) /*    low dark    */\n    const shadeDark60 = (hex`000C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`) /*  medium dark   */\n    const shadeDark80 = (hex`000F0F0F0F0F0F0F0F0F0F0F0F0F0F0F`) /*   very dark    */\n\n"]]},{"start1":4275,"length1":57,"diffs":[[1,"    //% blockId=shader_createRectangularShaderSprite\n"]]},{"start1":4421,"length1":48,"diffs":[[1,"    //% shadeLevel.shadow=shader_shadelevel\n"]]},{"start1":5163,"length1":51,"diffs":[[1,"    //% blockId=shader_createImageShaderSprite\n"]]},{"start1":5317,"length1":48,"diffs":[[1,"    //% shadeLevel.shadow=shader_shadelevel\n"]]},{"start1":6020,"length1":116,"diffs":[[1,"    //% blockId=shader_setShadeLevel\n    //% block=\" $spr set shade level to $shadeLevel=shader_shadelevel\"\n"]]},{"start1":6712,"length1":132,"diffs":[[1,"    //% blockId=shader_shadelevel\n"]]},{"start1":6769,"length1":80,"diffs":[[1,"    //% shim=TD_ID\n"]]}]}]},{"timestamp":1744804519204,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":336,"length1":210,"diffs":[[1,""]]},{"start1":1173,"length1":381,"diffs":[[1,""]]},{"start1":3010,"length1":12,"diffs":[[1,""]]},{"start1":3349,"length1":46,"diffs":[[1,"    //% shadeLevel.shadow=shader_obj_shadelevel\n"]]},{"start1":4043,"length1":43,"diffs":[[1,"     * @param shade level as enum or number\n"]]},{"start1":4253,"length1":46,"diffs":[[1,"    //% shadeLevel.shadow=shader_obj_shadelevel\n"]]},{"start1":4904,"length1":47,"diffs":[[1,"     * @param new shade level as enum or number\n"]]},{"start1":5001,"length1":73,"diffs":[[1,"    //% block=\" $spr set shade level to $shadeLevel=shader_obj_shadelevel\"\n"]]},{"start1":5566,"length1":49,"diffs":[[1,"     * enum block shadow for shade level \n"]]},{"start1":5660,"length1":0,"diffs":[[1,"    //% blockId=shader_obj_shadelevel\n"]]},{"start1":5720,"length1":29,"diffs":[[1,"    //% kindMemberName=ShadePattern\n"]]},{"start1":5847,"length1":47,"diffs":[[1,"    //% kindPromptHint=\"enter your member here\"\n"]]}]}]},{"timestamp":1744805116736,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1588,"length1":75,"diffs":[[1,"        if (shadeData[id] || (id >= shadeData.length || id < 0)) return shadeData[id]\n"]]},{"start1":1712,"length1":34,"diffs":[[1,"        return shadeData[shadeData.length-1]\n"]]},{"start1":3601,"length1":412,"diffs":[[1,"    export\n"]]},{"start1":3613,"length1":497,"diffs":[[1,""]]}]}]},{"timestamp":1744805716560,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":4039,"length1":227,"diffs":[[1,"    //% block=\"set $shadeId=shader_obj_kind_get in $palidx=colorindexpicker to $colidx=colorindexpicker\"\n    //% weight=100\n"]]},{"start1":4398,"length1":49,"diffs":[[1,"            pallete[palidx] = colidx\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":219,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1744793049652,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-shader-object\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1744802167519,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\nnamespace ShadeKind {\n\n    let id: number;\n\n    export function create() {\n        if (!id) id = 0\n        return id++\n    }\n\n    //% isKind\n    export const Dark100 = create()\n    \n    //% isKind \n    export const Dark75 = create()\n\n    //% isKind\n    export const Dark50 = create()\n\n    //% isKind\n    export const Dark25 = create()\n}\n\nnamespace SpriteKind {\n    //% isKind\n    export const Shader = SpriteKind.create();\n}\n\n//% color=\"#9e6eb8\" icon=\"\\uf0eb\"\nnamespace ShaderObj {\n\n    let shadeData: number[][] = [\n        // dark 100%\n        [15,15,15,15,\n        15,15,15,15,\n        15,15,15,15,\n        15,15,15,15],\n        // dark 75%\n        [15,12,15,15,\n        15,12,15,12,\n        15,12,15,15,\n        15,15,15,15],\n        // dark 50%\n        [15,11,12,12,\n        12,14,12,8,\n        15,8,12,15,\n        15,12,15,15],\n        // dark 25%\n        [15,13,10,11,\n        14,4,8,6,\n        12,6,11,12,\n        15,11,12,15]\n        ]\n\n    /* blank shade */\n    const shadeNull = (hex``)                                 /*   null shade   */\n    const shadeDark100 = (hex`00000000000000000000000000000000`) /*  blank shade   */\n    /* light shade */\n    const shadeLight100 = (hex`01010101010101010101010101010101`) /*   very light   */\n    const shadeLight75 = (hex`0D01050101010101010101010D01010D`) /*  medium light  */\n    const shadeLight50 = (hex`0B010301050109010901050D0301050B`) /*   low light    */\n    const shadeLight25 = (hex`0C01040503010709060103030B01040C`) /* a little light */\n    /* dark shade  */\n    const shadeDark20 = (hex`000D0A0B0E0408060C060B0C0F0B0C0F`) /* a little dark  */\n    const shadeDark40 = (hex`000B0C0C0C0E0C080F080C0F0F0C0F0F`) /*    low dark    */\n    const shadeDark60 = (hex`000C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`) /*  medium dark   */\n    const shadeDark80 = (hex`000F0F0F0F0F0F0F0F0F0F0F0F0F0F0F`) /*   very dark    */\n\n    let screenRowsBuffer: Buffer;\n    let maskRowsBuffer: Buffer;\n\n    export enum ShadeLevel {\n        //% block=\"dark 20%\"\n        Dark20 = 0,\n        //% block=\"dark 40%\"\n        Dark40 = 1,\n        //% block=\"dark 60%\"\n        Dark60 = 2,\n        //% block=\"dark 80%\"\n        Dark80 = 3,\n        //% block=\"dark 100%\"\n        Dark100 = 4,\n        //% block=\"light 25%\"\n        Light25 = -1,\n        //% block=\"light 50%\"\n        Light50 = -2,\n        //% block=\"light 75%\"\n        Light75 = -3,\n        //% block=\"light 100%\"\n        Light100 = -4,\n    }\n\n    function shadeImage(target: Image, left: number, top: number, mask: Image, palette: Buffer) {\n        if (!screenRowsBuffer || screenRowsBuffer.length < target.height) {\n            screenRowsBuffer = pins.createBuffer(target.height);\n        }\n        if (!maskRowsBuffer || maskRowsBuffer.length < target.height) {\n            maskRowsBuffer = pins.createBuffer(mask.height);\n        }\n\n        let targetX = left | 0;\n        let targetY = top | 0;\n        let y: number;\n        let x: number;\n\n        for (x = 0; x < mask.width; x++, targetX++) {\n            if (targetX >= target.width) break;\n            else if (targetX < 0) continue;\n\n            mask.getRows(x, maskRowsBuffer);\n            target.getRows(targetX, screenRowsBuffer);\n\n            for (y = 0, targetY = top | 0; y < mask.height; y++, targetY++) {\n                if (targetY >= target.height) break;\n                else if (targetY < 0) continue;\n\n                if (maskRowsBuffer[y]) screenRowsBuffer[targetY] = palette[screenRowsBuffer[targetY]];\n            }\n            target.setRows(targetX, screenRowsBuffer)\n        }\n    }\n\n    function shadeitem(shadeLevel: number): Buffer {\n        switch (shadeLevel) {\n            case 0: return shadeDark20;\n            case 1: return shadeDark40;\n            case 2: return shadeDark60;\n            case 3: return shadeDark80;\n            case 4: return shadeDark100;\n            case -1: return shadeLight25;\n            case -2: return shadeLight50;\n            case -3: return shadeLight75;\n            case -4: return shadeLight100;\n        }\n        if (shadeLevel < 0) return shadeLight100\n        return shadeDark100\n    }\n\n    /**\n     * create shader sprite as rectangle image.\n     * @param width of ractangle image\n     * @param height of ractangle image \n     * @param shade level as enum or number \n     */\n    //% blockId=shader_createRectangularShaderSprite\n    //% block=\"create rectangular shader with width $width height $height shade $shadeLevel\"\n    //% shadeLevel.shadow=shader_shadelevel\n    //% width.defl=16\n    //% height.defl=16\n    //% blockSetVariable=myShader\n    //% weight=90\n    export function createRectangularShaderSprite(width: number, height: number, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: Buffer;\n\n        palette = shadeitem(shadeLevel);\n        const i = image.create(width, height);\n        i.fill(3);\n\n        const sprite = new ShaderSprite(i, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n\n        return sprite\n    }\n\n    /**\n     * create shader sprite as your image.\n     * @param image to render \n     * @param shade level as enum or number\n     */\n    //% blockId=shader_createImageShaderSprite\n    //% block=\"create image shader with $image shade $shadeLevel\"\n    //% image.shadow=screen_image_picker\n    //% shadeLevel.shadow=shader_shadelevel\n    //% blockSetVariable=myShader\n    //% weight=100\n    export function createImageShaderSprite(image: Image, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: Buffer;\n\n        palette = shadeitem(shadeLevel);\n\n        const sprite = new ShaderSprite(image, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n        sprite.shadeRectangle = false;\n\n        return sprite\n    }\n\n    /**\n     * setting shade level as enum or number for shader sprite.\n     * @param current shader sprite not original sprite \n     * @param new shade level as enum or number\n     */\n    //% blockId=shader_setShadeLevel\n    //% block=\" $spr set shade level to $shadeLevel=shader_shadelevel\"\n    //% spr.shadow=variables_get spr.defl=myShader\n    //% weight=70\n    export function setShade(spr: Sprite, shadeLevel: number) {\n        let palette: Buffer;\n        palette = shadeitem(shadeLevel)\n        spr.data[\"__palette__\"] = palette as Buffer\n        if (spr instanceof ShaderSprite) {\n            (spr as ShaderSprite).onPaletteChanged(); // Update palette when set\n        } else {\n            throw (`this sprite is not an shader sprite ${spr}`);\n        }\n    }\n\n    /**\n     * enum block shadow for shade level \n     * but not used it.\n     */\n    //% blockHidden\n    //% blockId=shader_shadelevel\n    //% block=\"$level\"\n    //% shim=TD_ID\n    //% weight=50\n    export function _shadeLevel(level: ShadeLevel): number {\n        return level;\n    }\n\n    class ShaderSprite extends Sprite {\n        protected shadePalette: Buffer;\n        shadeRectangle: boolean;\n\n        constructor(image: Image, shadePalette: Buffer) {\n            super(image);\n            this.data[\"__palette__\"] = shadePalette as Buffer\n            this.shadePalette = shadePalette;\n            this.shadeRectangle = true;\n            this.onPaletteChanged();\n        }\n\n\n        onPaletteChanged() {\n            if (this.shadePalette !== this.data[\"__palette__\"]) this.shadePalette = this.data[\"__palette__\"] as Buffer;\n        }\n\n        __drawCore(camera: scene.Camera) {\n            if (this.isOutOfScreen(camera)) return;\n\n            const ox = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetX;\n            const oy = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetY;\n\n            const l = this.left - ox;\n            const t = this.top - oy;\n\n            if (this.shadeRectangle) {\n                screen.mapRect(l, t, this.image.width, this.image.height, this.shadePalette);\n            } else {\n                shadeImage(screen, l, t, this.image, this.shadePalette);\n            }\n\n            if (this.flags & SpriteFlag.ShowPhysics) {\n                const font = image.font5;\n                const margin = 2;\n                let tx = l;\n                let ty = t + this.height + margin;\n                screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n                tx -= font.charWidth;\n                if (this.vx || this.vy) {\n                    ty += font.charHeight + margin;\n                    screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n                }\n                if (this.ax || this.ay) {\n                    ty += font.charHeight + margin;\n                    screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n                }\n            }\n\n            // debug info\n            if (game.debug) {\n                screen.drawRect(\n                    Fx.toInt(this._hitbox.left) - ox,\n                    Fx.toInt(this._hitbox.top) - oy,\n                    Fx.toInt(this._hitbox.width),\n                    Fx.toInt(this._hitbox.height),\n                    1\n                );\n            }\n\n        }\n    }\n\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-shader-object\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1744803972729,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\nnamespace ShadeKind {\n\n    let id: number;\n\n    export function create() {\n        if (!id) id = 0\n        return id++\n    }\n\n    //% isKind\n    export const Dark100 = create()\n    \n    //% isKind \n    export const Dark75 = create()\n\n    //% isKind\n    export const Dark50 = create()\n\n    //% isKind\n    export const Dark25 = create()\n}\n\nnamespace SpriteKind {\n    //% isKind\n    export const Shader = SpriteKind.create();\n}\n\n//% color=\"#9e6eb8\" icon=\"\\uf0eb\"\nnamespace ShaderObj {\n\n    let shadeData: number[][] = [\n        // dark 100%\n        [15,15,15,15,15,15,15,15,\n        15,15,15,15,15,15,15,15],\n        // dark 75%\n        [15,12,15,15,15,12,15,12,\n        15,12,15,15,15,15,15,15],\n        // dark 50%\n        [15,11,12,12,12,14,12,8,\n        15,8,12,15,15,12,15,15],\n        // dark 25%\n        [15,13,10,11,14,4,8,6,\n        12,6,11,12,15,11,12,15],\n        // light 100%\n        [1,1,1,1,1,1,1,1,\n        1,1,1,1,1,1,1,1],\n        // light 75%\n        [13,1,5,1,1,1,1,1,\n        1,1,1,1,13,1,1,13],\n        // light 50%\n        [11,1,3,1,5,1,9,1,\n        9,1,5,13,3,1,5,11],\n        // light 25%\n        [12,1,4,5,3,1,7,9,\n        6,1,3,3,11,1,4,12]\n    ]\n\n    function createArrNum(len: number) {\n        let uarrnv: number[] = []\n        for (let i = 0;i < len;i++) uarrnv.push(0)\n        return uarrnv\n    }\n\n    /* blank shade */\n    const shadeNull = (hex``)                                 /*   null shade   */\n    const shadeDark100 = (hex`00000000000000000000000000000000`) /*  blank shade   */\n    /* light shade */\n    const shadeLight100 = (hex`01010101010101010101010101010101`) /*   very light   */\n    const shadeLight75 = (hex`0D01050101010101010101010D01010D`) /*  medium light  */\n    const shadeLight50 = (hex`0B010301050109010901050D0301050B`) /*   low light    */\n    const shadeLight25 = (hex`0C01040503010709060103030B01040C`) /* a little light */\n    /* dark shade  */\n    const shadeDark20 = (hex`000D0A0B0E0408060C060B0C0F0B0C0F`) /* a little dark  */\n    const shadeDark40 = (hex`000B0C0C0C0E0C080F080C0F0F0C0F0F`) /*    low dark    */\n    const shadeDark60 = (hex`000C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`) /*  medium dark   */\n    const shadeDark80 = (hex`000F0F0F0F0F0F0F0F0F0F0F0F0F0F0F`) /*   very dark    */\n\n    let screenRowsBuffer: Image;\n    let maskRowsBuffer: Image;\n\n    export enum ShadeLevel {\n        //% block=\"dark 20%\"\n        Dark20 = 0,\n        //% block=\"dark 40%\"\n        Dark40 = 1,\n        //% block=\"dark 60%\"\n        Dark60 = 2,\n        //% block=\"dark 80%\"\n        Dark80 = 3,\n        //% block=\"dark 100%\"\n        Dark100 = 4,\n        //% block=\"light 25%\"\n        Light25 = -1,\n        //% block=\"light 50%\"\n        Light50 = -2,\n        //% block=\"light 75%\"\n        Light75 = -3,\n        //% block=\"light 100%\"\n        Light100 = -4,\n    }\n\n    function shadeImage(target: Image, left: number, top: number, mask: Image, palette: number[]) {\n        if (!screenRowsBuffer || screenRowsBuffer.height < target.height) {\n            screenRowsBuffer = image.create(1,target.height);\n        }\n        if (!maskRowsBuffer || maskRowsBuffer.height < target.height) {\n            maskRowsBuffer = image.create(1,mask.height);\n        }\n\n        let targetX = left | 0;\n        let targetY = top | 0;\n        let y: number;\n        let x: number;\n\n        for (x = 0; x < mask.width; x++, targetX++) {\n            if (targetX >= target.width) break;\n            else if (targetX < 0) continue;\n\n            maskRowsBuffer.blitRow(0,0,mask,x,mask.height)\n            screenRowsBuffer.blitRow(0,0,target,targetX,target.height);\n\n            for (y = 0, targetY = top | 0; y < mask.height; y++, targetY++) {\n                if (targetY >= target.height) break;\n                else if (targetY < 0) continue;\n\n                if (maskRowsBuffer.getPixel(0,y)) screenRowsBuffer.setPixel(0,targetY,palette[screenRowsBuffer.getPixel(0,targetY)]);\n            }\n            target.drawImage(screenRowsBuffer,targetX,0)\n        }\n    }\n\n    function shadeitem(shadeIndex: number): number[] {\n        return shadeData[shadeIndex]\n    }\n\n    /**\n     * create shader sprite as rectangle image.\n     * @param width of ractangle image\n     * @param height of ractangle image \n     * @param shade level as enum or number \n     */\n    //% blockId=shader_createRectangularShaderSprite\n    //% block=\"create rectangular shader with width $width height $height shade $shadeLevel\"\n    //% shadeLevel.shadow=shader_shadelevel\n    //% width.defl=16\n    //% height.defl=16\n    //% blockSetVariable=myShader\n    //% weight=90\n    export function createRectangularShaderSprite(width: number, height: number, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: number[];\n\n        palette = shadeitem(shadeLevel);\n        const i = image.create(width, height);\n        i.fill(3);\n\n        const sprite = new ShaderSprite(i, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n\n        return sprite\n    }\n\n    /**\n     * create shader sprite as your image.\n     * @param image to render \n     * @param shade level as enum or number\n     */\n    //% blockId=shader_createImageShaderSprite\n    //% block=\"create image shader with $image shade $shadeLevel\"\n    //% image.shadow=screen_image_picker\n    //% shadeLevel.shadow=shader_shadelevel\n    //% blockSetVariable=myShader\n    //% weight=100\n    export function createImageShaderSprite(image: Image, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: number[];\n\n        palette = shadeitem(shadeLevel);\n\n        const sprite = new ShaderSprite(image, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n        sprite.shadeRectangle = false;\n\n        return sprite\n    }\n\n    /**\n     * setting shade level as enum or number for shader sprite.\n     * @param current shader sprite not original sprite \n     * @param new shade level as enum or number\n     */\n    //% blockId=shader_setShadeLevel\n    //% block=\" $spr set shade level to $shadeLevel=shader_shadelevel\"\n    //% spr.shadow=variables_get spr.defl=myShader\n    //% weight=70\n    export function setShade(spr: Sprite, shadeLevel: number) {\n        let palette: number[];\n        palette = shadeitem(shadeLevel)\n        spr.data[\"__palette__\"] = palette as number[]\n        if (spr instanceof ShaderSprite) {\n            (spr as ShaderSprite).onPaletteChanged(); // Update palette when set\n        } else {\n            throw (`this sprite is not an shader sprite ${spr}`);\n        }\n    }\n\n    /**\n     * enum block shadow for shade level \n     * but not used it.\n     */\n    //% blockHidden\n    //% blockId=shader_shadelevel\n    //% block=\"$level\"\n    //% shim=TD_ID\n    //% weight=50\n    export function _shadeLevel(level: ShadeLevel): number {\n        return level;\n    }\n\n    class ShaderSprite extends Sprite {\n        protected shadePalette: number[];\n        shadeRectangle: boolean;\n\n        constructor(image: Image, shadePalette: number[]) {\n            super(image);\n            this.data[\"__palette__\"] = shadePalette as number[]\n            this.shadePalette = shadePalette;\n            this.shadeRectangle = true;\n            this.onPaletteChanged();\n        }\n\n\n        onPaletteChanged() {\n            if (this.shadePalette !== this.data[\"__palette__\"]) this.shadePalette = this.data[\"__palette__\"] as number[];\n        }\n\n        __drawCore(camera: scene.Camera) {\n            if (this.isOutOfScreen(camera)) return;\n\n            const ox = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetX;\n            const oy = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetY;\n\n            const l = this.left - ox;\n            const t = this.top - oy;\n\n            if (this.shadeRectangle) {\n                this.image.fill(3)\n            }\n            shadeImage(screen, l, t, this.image, this.shadePalette);\n\n            if (this.flags & SpriteFlag.ShowPhysics) {\n                const font = image.font5;\n                const margin = 2;\n                let tx = l;\n                let ty = t + this.height + margin;\n                screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n                tx -= font.charWidth;\n                if (this.vx || this.vy) {\n                    ty += font.charHeight + margin;\n                    screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n                }\n                if (this.ax || this.ay) {\n                    ty += font.charHeight + margin;\n                    screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n                }\n            }\n\n            // debug info\n            if (game.debug) {\n                screen.drawRect(\n                    Fx.toInt(this._hitbox.left) - ox,\n                    Fx.toInt(this._hitbox.top) - oy,\n                    Fx.toInt(this._hitbox.width),\n                    Fx.toInt(this._hitbox.height),\n                    1\n                );\n            }\n\n        }\n    }\n\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-shader-object\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1744805773429,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\nnamespace ShadeKind {\n\n    let id: number;\n\n    export function create() {\n        if (!id) id = 0\n        return id++\n    }\n\n    //% isKind\n    export const Dark100 = create()\n    \n    //% isKind \n    export const Dark75 = create()\n\n    //% isKind\n    export const Dark50 = create()\n\n    //% isKind\n    export const Dark25 = create()\n\n    //% isKind\n    export const Light100 = create()\n\n    //% isKind \n    export const Light75 = create()\n\n    //% isKind\n    export const Light50 = create()\n\n    //% isKind\n    export const Light25 = create()\n}\n\nnamespace SpriteKind {\n    //% isKind\n    export const Shader = SpriteKind.create();\n}\n\n//% color=\"#9e6eb8\" icon=\"\\uf0eb\"\nnamespace ShaderObj {\n\n    let shadeData: number[][] = [\n        // dark 100%\n        [15,15,15,15,15,15,15,15,\n        15,15,15,15,15,15,15,15],\n        // dark 75%\n        [15,12,15,15,15,12,15,12,\n        15,12,15,15,15,15,15,15],\n        // dark 50%\n        [15,11,12,12,12,14,12,8,\n        15,8,12,15,15,12,15,15],\n        // dark 25%\n        [15,13,10,11,14,4,8,6,\n        12,6,11,12,15,11,12,15],\n        // light 100%\n        [1,1,1,1,1,1,1,1,\n        1,1,1,1,1,1,1,1],\n        // light 75%\n        [13,1,5,1,1,1,1,1,\n        1,1,1,1,13,1,1,13],\n        // light 50%\n        [11,1,3,1,5,1,9,1,\n        9,1,5,13,3,1,5,11],\n        // light 25%\n        [12,1,4,5,3,1,7,9,\n        6,1,3,3,11,1,4,12]\n    ]\n\n    function newNumArr(len: number) {\n        let uarrn: number[] = []\n        for (let addidx = 0;addidx < len;addidx++) uarrn.push(0)\n        return uarrn\n    }\n\n    function checkNewShade(id: number) {\n        if (shadeData[id] || (id >= shadeData.length || id < 0)) return id\n        shadeData.push(newNumArr(16))\n        return shadeData.length-1\n    }\n\n    let screenRowsBuffer: Image;\n    let maskRowsBuffer: Image;\n\n    export enum ShadeLevel {\n        //% block=\"dark 20%\"\n        Dark20 = 0,\n        //% block=\"dark 40%\"\n        Dark40 = 1,\n        //% block=\"dark 60%\"\n        Dark60 = 2,\n        //% block=\"dark 80%\"\n        Dark80 = 3,\n        //% block=\"dark 100%\"\n        Dark100 = 4,\n        //% block=\"light 25%\"\n        Light25 = -1,\n        //% block=\"light 50%\"\n        Light50 = -2,\n        //% block=\"light 75%\"\n        Light75 = -3,\n        //% block=\"light 100%\"\n        Light100 = -4,\n    }\n\n    function shadeImage(target: Image, left: number, top: number, mask: Image, palette: number[]) {\n        if (!screenRowsBuffer || screenRowsBuffer.height < target.height) {\n            screenRowsBuffer = image.create(1,target.height);\n        }\n        if (!maskRowsBuffer || maskRowsBuffer.height < target.height) {\n            maskRowsBuffer = image.create(1,mask.height);\n        }\n\n        let targetX = left | 0;\n        let targetY = top | 0;\n        let y: number;\n        let x: number;\n\n        for (x = 0; x < mask.width; x++, targetX++) {\n            if (targetX >= target.width) break;\n            else if (targetX < 0) continue;\n\n            maskRowsBuffer.blitRow(0,0,mask,x,mask.height)\n            screenRowsBuffer.blitRow(0,0,target,targetX,target.height);\n\n            for (y = 0, targetY = top | 0; y < mask.height; y++, targetY++) {\n                if (targetY >= target.height) break;\n                else if (targetY < 0) continue;\n\n                if (maskRowsBuffer.getPixel(0,y)) screenRowsBuffer.setPixel(0,targetY,palette[screenRowsBuffer.getPixel(0,targetY)]);\n            }\n            target.drawImage(screenRowsBuffer,targetX,0)\n        }\n    }\n\n    function shadeitem(shadeIndex: number): number[] {\n        return shadeData[shadeIndex]\n    }\n\n    //% blockId=shader_obj_setpalletecolor\n    //% block=\"set $shadeId=shader_obj_kind_get in $palidx=colorindexpicker to $colidx=colorindexpicker\"\n    //% weight=100\n    export function setShadePattern(shadeID: number, palidx: number, colidx: number) {\n        shadeID = checkNewShade(shadeID)\n        let pallete = shadeData[shadeID]\n        pallete[palidx] = colidx\n        shadeData[shadeID] = pallete\n    }\n\n    //% blockId=shader_obj_setpalletecolorlist\n    //% block=\"set $shadeId=shader_obj_kind_get in $palidx=colorindexpicker to $colidx=colorindexpicker\"\n    //% palidx.shadow=lists_create_with\n    //% weight=100\n    export function setShadePatternList(shadeID: number, palidx: number[], colidx: number[]) {\n        shadeID = checkNewShade(shadeID)\n        let pallete = shadeData[shadeID]\n        for (let pali = 0;pali < palidx.length; pali++) {\n            pallete[palidx[pali]] = colidx[pali]\n        }\n        shadeData[shadeID] = pallete\n    }\n\n    /**\n     * create shader sprite as rectangle image.\n     * @param width of ractangle image\n     * @param height of ractangle image \n     * @param shade level as enum or number \n     */\n    //% blockId=shader_obj_createRectangularShaderSprite\n    //% block=\"create rectangular shader with width $width height $height shade $shadeLevel\"\n    //% shadeLevel.shadow=shader_obj_kind_get\n    //% width.defl=16\n    //% height.defl=16\n    //% blockSetVariable=myShader\n    //% weight=90\n    export function createRectangularShaderSprite(width: number, height: number, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: number[];\n\n        palette = shadeitem(shadeLevel);\n        const i = image.create(width, height);\n        i.fill(3);\n\n        const sprite = new ShaderSprite(i, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n\n        return sprite\n    }\n\n    /**\n     * create shader sprite as your image.\n     * @param image to render \n     * @param shade pattern as kind number\n     */\n    //% blockId=shader_obj_createImageShaderSprite\n    //% block=\"create image shader with $image shade $shadeLevel\"\n    //% image.shadow=screen_image_picker\n    //% shadeLevel.shadow=shader_obj_kind_get\n    //% blockSetVariable=myShader\n    //% weight=100\n    export function createImageShaderSprite(image: Image, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: number[];\n\n        palette = shadeitem(shadeLevel);\n\n        const sprite = new ShaderSprite(image, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n        sprite.shadeRectangle = false;\n\n        return sprite\n    }\n\n    /**\n     * setting shade level as enum or number for shader sprite.\n     * @param current shader sprite not original sprite \n     * @param new shade pattern as kind number\n     */\n    //% blockId=shader_obj_setShadeLevel\n    //% block=\" $spr set shade level to $shadeLevel=shader_obj_kind_get\"\n    //% spr.shadow=variables_get spr.defl=myShader\n    //% weight=70\n    export function setShade(spr: Sprite, shadeLevel: number) {\n        let palette: number[];\n        palette = shadeitem(shadeLevel)\n        spr.data[\"__palette__\"] = palette as number[]\n        if (spr instanceof ShaderSprite) {\n            (spr as ShaderSprite).onPaletteChanged(); // Update palette when set\n        } else {\n            throw (`this sprite is not an shader sprite ${spr}`);\n        }\n    }\n\n    /**\n     * kind number block shadow for shade level \n     * but not used it.\n     */\n    //% blockHidden\n    //% shim=KIND_GET\n    //% kindMemberName=Shade\n    //% blockId=shader_obj_kind_get\n    //% block=\"$level\"\n    //% kindNamespace=ShadeKind\n    //% kindPromptHint=\"enter your shade here\"\n    //% weight=50\n    export function _shadeLevel(level: ShadeLevel): number {\n        return level;\n    }\n\n    class ShaderSprite extends Sprite {\n        protected shadePalette: number[];\n        shadeRectangle: boolean;\n\n        constructor(image: Image, shadePalette: number[]) {\n            super(image);\n            this.data[\"__palette__\"] = shadePalette as number[]\n            this.shadePalette = shadePalette;\n            this.shadeRectangle = true;\n            this.onPaletteChanged();\n        }\n\n\n        onPaletteChanged() {\n            if (this.shadePalette !== this.data[\"__palette__\"]) this.shadePalette = this.data[\"__palette__\"] as number[];\n        }\n\n        __drawCore(camera: scene.Camera) {\n            if (this.isOutOfScreen(camera)) return;\n\n            const ox = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetX;\n            const oy = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetY;\n\n            const l = this.left - ox;\n            const t = this.top - oy;\n\n            if (this.shadeRectangle) {\n                this.image.fill(3)\n            }\n            shadeImage(screen, l, t, this.image, this.shadePalette);\n\n            if (this.flags & SpriteFlag.ShowPhysics) {\n                const font = image.font5;\n                const margin = 2;\n                let tx = l;\n                let ty = t + this.height + margin;\n                screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n                tx -= font.charWidth;\n                if (this.vx || this.vy) {\n                    ty += font.charHeight + margin;\n                    screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n                }\n                if (this.ax || this.ay) {\n                    ty += font.charHeight + margin;\n                    screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n                }\n            }\n\n            // debug info\n            if (game.debug) {\n                screen.drawRect(\n                    Fx.toInt(this._hitbox.left) - ox,\n                    Fx.toInt(this._hitbox.top) - oy,\n                    Fx.toInt(this._hitbox.width),\n                    Fx.toInt(this._hitbox.height),\n                    1\n                );\n            }\n\n        }\n    }\n\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-shader-object\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1744805948475}